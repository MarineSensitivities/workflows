---
title: "Tabulate Species"
format: html
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
librarian::shelf(
  DBI, dplyr, dbplyr, glue, here, httr2, jsonlite, 
  MarineSensitivity/msens,
  readr, sf, stringr, tictoc, tidyr)
source("libs/db.R")
```

```{r}
# TODO: add req_timeout(60*20) to R fxn so timeout is 20 min, not 10 min
# https://httr2.r-lib.org/reference/req_timeout.html
# erEGOM-paEGM: 921.262 sec / 60 = 15.4 min

dbExecute(
  con,"CREATE TABLE IF NOT EXISTS 
    public.ply_species(
      ply_tbl text,
      ply_fld text,
      ply_key text,
      sp_key text,
      area_km2 double precision,
      avg_suit double precision)")

dbExecute(
  con, "DELETE FROM public.ply_species")

# get_species_by_feature_localdb <- function(
    #     schema.table = "raw.mr_eez",
#     where        = "mrgid = 8442"){

# schema.table = "public.ply_ecoblks"
# where        = "ecoarea_key = 'erCAC-paCEC'"

source(here("../workflows/libs/db.R")) # define: con

# tbl(con, "ply_ecoblks") |> 
#   arrange(br_er_pa_pd_bk_key) |> 
#   head(1) |> 
#   pull(br_er_pa_pd_bk_key) # "AK_CBS_BFT_NR05-01_6002"
schema = "public"
table  = "ply_ecoblks"
fld    = "br_er_pa_pd_bk_key"

fld_geom <- dbGetQuery(
  con,
  glue("
      SELECT f_geometry_column
      FROM geometry_columns
      WHERE
        f_table_schema = '{schema}' AND
        f_table_name   = '{table}';")) |>
  pull(f_geometry_column)
# message(glue("schema.table: '{schema}.{table}'; fld_geom: '{fld_geom}'"))

keys <- tbl(con, table) |> 
  arrange(!!as.symbol(fld)) |>
  pull(!!as.symbol(fld))

n_f   <- format(length(flds), big.mark=',')
n_f_c <- nchar(n_f)
# for (i in 1:length(flds)){ # i = 2000
# for (i in 1:100){ # i = 2000
for (i in 101:length(flds)){ # i = 2000
  
  key   <- keys[i]
  where <- glue("{fld} = '{key}'")
  
  if (i %% 10 == 0)
    message(glue(
      "{str_pad(format(i, big.mark=','), nchar_i)} / {n_f}: {key} ~ {Sys.time()}"))
  
  q <- glue("
    WITH
      c AS (
        SELECT
        c.cell_id,
        c.area_km2 AS cell_km2,
        CASE
          WHEN ST_CoveredBy(c.geom, a.{fld_geom})
            THEN c.geom
          ELSE
            ST_Multi(ST_Intersection(c.geom, a.{fld_geom}))
        END AS geom
      FROM
        aquamaps.cells c
        INNER JOIN {table} a
          ON ST_Intersects(c.geom, a.{fld_geom})
            AND NOT ST_Touches(c.geom, a.{fld_geom})
      WHERE
        a.{where}
      ORDER BY
        c.cell_id),
    k AS (
      SELECT *,
        ST_AREA(geom::geography) / (1000 * 1000) AS aoi_km2
      FROM c),
    a AS (
      SELECT *,
        aoi_km2 / cell_km2 AS pct_cell
      FROM k),
    s AS (
      SELECT a.*,
        sc.sp_key, sc.probability
      FROM a
        LEFT JOIN aquamaps.spp_cells sc
          ON a.cell_id = sc.cell_id),
    g AS (
      SELECT
        sp_key,
        COUNT(*)                                  AS n_cells,
        AVG(pct_cell)                             AS avg_pct_cell,
        SUM(aoi_km2)                              AS area_km2,
        SUM(probability * aoi_km2) / SUM(aoi_km2) AS avg_suit
      FROM s
      GROUP BY sp_key),
    r AS (
      SELECT
        sp_key, area_km2, avg_suit
      FROM
        g
        LEFT JOIN aquamaps.spp USING (sp_key))
    INSERT INTO public.ply_species(
      ply_tbl, ply_fld, ply_key, sp_key, area_km2, avg_suit)
    SELECT
      '{schema}.{table}' AS ply_tbl, 
      '{fld}' AS ply_fld, 
      '{key}' AS ply_key,
      sp_key, 
      area_km2, 
      avg_suit
    FROM r")
  # message(q)
  
  dbExecute(con, q)
}

```


## Fetch and Store Species Data

```{r}
insert_ply_species <- function(
    schema       = "public",
    tbl          = "ply_ecoareas",
    fld_key      = "ecoarea_key",
    tbl_ply_spp  = "ply_species",
    redo = F){
  
  # keys, all
  keys <- dbGetQuery(con, glue("SELECT {fld_key} FROM {schema}.{tbl} ORDER BY {fld_key}")) |> 
    pull(fld_key)
  
  # keys, done
  if (dbExistsTable(con, tbl_ply_spp) & !redo) {
    keys_done <- dbGetQuery(con, glue("SELECT DISTINCT ply_key FROM {tbl_ply_spp} WHERE ply_tbl = '{schema}.{tbl}' ORDER BY ply_key")) |> 
      pull(ply_key)
    
    keys <- setdiff(keys, keys_done)
  }
  
  if (length(keys) == 0){
    message(glue("All keys in {tbl}.{fld_key} were already processed and inserted into {tbl_ply_spp} ~ {Sys.time()}"))
    return(NULL)
  }
  
  # Iterate over each region key
  for (i in 1:length(keys)) {  # key = rgn_keys[1] # bad: i = 1; key = "ALA" # good: key = "WGM"
    key = keys[i]
    
    # message with time stamp
    tic()
    message(glue("{sprintf('%02d',i)}/{length(keys)}: {key} ~ {Sys.time()}"))
    
    # Fetch species data from API; wrap in tryCatch to avoid breaking the loop
    d_spp <- tryCatch({
      # msens::get_species_by_feature(
      get_species_by_feature_localdb(
        glue("public.{tbl}"),
        glue("{fld_key} = '{key}'")) }, 
      error = function(e) {
        message(glue(
          "
        Error fetching species data: {e$message}
        ~ {Sys.time()}"))
        source("libs/db.R") # reset database con
        return(NULL)
      })
    
    if (is.null(d_spp))
      next
    
    # add columns identifying polygon for species
    d_spp <- d_spp |>
      mutate(
        ply_tbl = glue("{schema}.{tbl}"),
        ply_fld = fld_key,
        ply_key = key) |>
      relocate(ply_tbl, ply_fld, ply_key)
    
    # clear existing if table exists
    if (dbExistsTable(con, tbl_ply_spp)) {
      dbExecute(con, glue("DELETE FROM {tbl_ply_spp} WHERE ply_tbl = '{schema}.{tbl}' AND ply_fld = '{fld_key}' AND ply_key = '{key}'"))
    }
      
    # append to database
    dbWriteTable(con, tbl_ply_spp, d_spp, append = TRUE, row.names = FALSE)

    toc <- toc(quiet = T)
    message(glue("{sprintf('%02d',i)}/{length(keys)}: {key} ~ {toc$callback_msg}"))
  }
}

# dbRemoveTable(con, "ply_species")

insert_ply_species(
  schema       = "public",
  tbl          = "ply_ecoareas",
  fld_key      = "ecoarea_key",
  tbl_ply_spp  = "ply_species",
  redo         = F)

# 01/17: erEGOM-paEGM ~ 2024-12-21 15:43:57.250182
# Error fetching species data: Failed to perform HTTP request.
# ~ 2024-12-21 15:53:58.042009
# 06/17: erGOA-paGOA ~ 2024-12-21 16:03:20.086948
# Error fetching species data: Failed to perform HTTP request.
# ~ 2024-12-21 16:13:20.706389
# 10/17: erNECS-paNOA ~ 2024-12-21 16:26:41.31597
# Error fetching species data: Failed to perform HTTP request.
# ~ 2024-12-21 16:36:41.934764
# 11/17: erSECS-paFLS ~ 2024-12-21 16:36:42.155532
# Error fetching species data: Failed to perform HTTP request.
# ~ 2024-12-21 16:46:42.77022

insert_ply_species(
  schema       = "public",
  tbl          = "ply_ecorgns",
  fld_key      = "ecorgn_key",
  tbl_ply_spp  = "ply_species",
  redo = F)
```



## OLD db: Fetch and Store Species Data

```{r}
# show region keys
dbGetQuery(con, glue("SELECT rgn_key FROM public.ply_rgns ORDER BY rgn_key")) |> 
  pull(rgn_key)
```

region keys (n = 27):
```
 [1] "ALA" "ALB" "BFT" "BOW" "CEC" "CGM" "CHU" "COK" "EGM"
[10] "FLS" "GEO" "GOA" "HI"  "HOP" "KOD" "MAT" "MDA" "NAL"
[19] "NAV" "NOA" "NOC" "NOR" "SHU" "SOA" "SOC" "WAO" "WGM"
```

```{r}
#| eval: false
insert_ply_species(
  schema       = "public",
  tbl          = "ply_shlfs",
  fld_key      = "shlf_key",
  tbl_ply_spp  = "ply_species",
  redo         = F)
```

```{r}
#| eval: false
insert_ply_species(
  schema       = "public",
  tbl          = "ply_rgns",
  fld_key      = "rgn_key",
  tbl_ply_spp  = "ply_species",
  redo = F)
```


Executing above:
```
01: ALA ~ 2024-12-11 23:32:20.493056
Error fetching species data for ALA: HTTP 500 Internal Server Error.
01: ALA ~ 1.41 sec elapsed
02: ALB ~ 2024-12-11 23:32:21.903263
Error fetching species data for ALB: HTTP 500 Internal Server Error.
02: ALB ~ 1.509 sec elapsed
03: BFT ~ 2024-12-11 23:32:23.413059
03: BFT ~ 35.018 sec elapsed
04: BOW ~ 2024-12-11 23:32:58.431392
Error fetching species data for BOW: HTTP 500 Internal Server Error.
04: BOW ~ 1.391 sec elapsed
05: CEC ~ 2024-12-11 23:32:59.822888
05: CEC ~ 93.324 sec elapsed
06: CGM ~ 2024-12-11 23:34:33.14729
06: CGM ~ 343.167 sec elapsed
07: CHU ~ 2024-12-11 23:40:16.315158
07: CHU ~ 20.115 sec elapsed
08: COK ~ 2024-12-11 23:40:36.431037
08: COK ~ 156.458 sec elapsed                                         
09: EGM ~ 2024-12-11 23:43:12.889954
Error fetching species data for EGM: HTTP 500 Internal Server Error.
09: EGM ~ 27.012 sec elapsed
10: FLS ~ 2024-12-11 23:43:39.902751
10: FLS ~ 607.625 sec elapsed                                 
11: GEO ~ 2024-12-11 23:53:47.529269
11: GEO ~ 199.316 sec elapsed                                 
12: GOA ~ 2024-12-11 23:57:06.845524
Error fetching species data for GOA: Failed to perform HTTP request.
12: GOA ~ 328.706 sec elapsed
13: HI ~ 2024-12-12 00:02:35.552604
Error fetching species data for HI: Failed to perform HTTP request.
...
06: HI ~ 1.417 sec elapsed
07: HOP ~ 2024-12-12 00:46:31.430755
07: HOP ~ 31.362 sec elapsed          
08: KOD ~ 2024-12-12 00:47:02.792726
08: KOD ~ 144.358 sec elapsed         
09: MAT ~ 2024-12-12 00:49:27.151273
09: MAT ~ 30.936 sec elapsed          
10: MDA ~ 2024-12-12 00:49:58.088405
10: MDA ~ 480.974 sec elapsed         
11: NAL ~ 2024-12-12 00:57:59.063676
11: NAL ~ 172.836 sec elapsed         
12: NAV ~ 2024-12-12 01:00:51.900245
12: NAV ~ 3.234 sec elapsed           
13: NOA ~ 2024-12-12 01:00:55.13549
13: NOA ~ 667.073 sec elapsed         
14: NOC ~ 2024-12-12 01:12:02.20922
14: NOC ~ 102.602 sec elapsed         
15: NOR ~ 2024-12-12 01:13:44.812222
15: NOR ~ 93.109 sec elapsed          
16: SHU ~ 2024-12-12 01:15:17.922195
16: SHU ~ 94.259 sec elapsed          
17: SOA ~ 2024-12-12 01:16:52.182344
17: SOA ~ 664.422 sec elapsed         
18: SOC ~ 2024-12-12 01:27:56.605175
18: SOC ~ 467.248 sec elapsed         
19: WAO ~ 2024-12-12 01:35:43.853924
19: WAO ~ 154.774 sec elapsed         
20: WGM ~ 2024-12-12 01:38:18.627972
20: WGM ~ 182.608 sec elapsed
```

Error fetching species data for:
```
ALA
ALB
BOW
EGM
GOA
HI
```

## Assign Taxa Groups

```{r taxa groups}
where_taxa <- list(
  mammals = "class = 'Mammalia' 
    AND \"order\" IN ('Cetacea', 'Carnivora')
    AND family IN ('Balaenopteridae', 'Delphinidae', 'Phocidae', 'Otariidae')",
  
  benthos = "(phylum = 'Annelida' AND class = 'Polychaeta')
    OR (phylum = 'Mollusca' AND class IN ('Bivalvia', 'Gastropoda'))
    OR (phylum = 'Echinodermata')
    OR (phylum = 'Arthropoda' AND class = 'Malacostraca')",
  
  corals = "phylum = 'Cnidaria'
    AND class IN ('Anthozoa', 'Hydrozoa')
    AND \"order\" IN ('Scleractinia', 'Alcyonacea')",
  
  pelagic_fish = "phylum = 'Chordata'
    AND class = 'Actinopterygii'
    AND \"order\" IN ('Clupeiformes', 'Perciformes', 'Gadiformes')
    AND family IN ('Scombridae', 'Clupeidae', 'Gadidae')",
  
  seabirds = "class = 'Aves'
    AND \"order\" IN ('Charadriiformes', 'Procellariiformes', 'Pelecaniformes')
    AND family IN ('Laridae', 'Procellariidae', 'Sulidae', 'Phalacrocoracidae')",
  
  turtles = "class = 'Reptilia'
    AND \"order\" = 'Testudines'
    AND family IN ('Cheloniidae', 'Dermochelyidae')",
  
  elasmo = "class = 'Chondrichthyes'
    AND (\"order\" IN ('Lamniformes', 'Carcharhiniformes', 'Rajiformes', 'Myliobatiformes')
    OR family IN ('Sphyrnidae', 'Pristidae', 'Mobulidae'))",
  
  other_fish = "phylum = 'Chordata'
    AND class = 'Actinopterygii'
    AND \"order\" NOT IN ('Clupeiformes', 'Perciformes', 'Gadiformes')
    AND family NOT IN ('Scombridae', 'Clupeidae', 'Gadidae')",
  
  other_inverts = "phylum IN ('Porifera', 'Bryozoa', 'Brachiopoda', 'Chaetognatha', 'Nemertea')
    OR (phylum = 'Arthropoda' AND class NOT IN ('Malacostraca'))
    OR (phylum = 'Mollusca' AND class NOT IN ('Bivalvia', 'Gastropoda'))"
)

# add column taxa if not already present
if (!("taxa" %in% dbListFields(con, tbl_ply_spp))) {
  dbExecute(con, glue("ALTER TABLE {tbl_ply_spp} ADD COLUMN taxa TEXT"))
}

# Assign taxa groupings to species
for (taxa in names(where_taxa)) { # taxa = names(where_taxa)[1]
  dbExecute(con, glue("UPDATE {tbl_ply_spp} SET taxa = '{taxa}' WHERE {where_taxa[[taxa]]}"))
}
```

```{r ck_ply_species_taxa}
# TODO: move to single species

d_pspp <- tbl(con, "ply_species") |>
  distinct(phylum, class, order, family, genus, species) |> 
  collect()

table(d_pspp$phylum)
table(d_pspp$class, useNA = "ifany")

with(
  d_pspp,
  table(phylum, class, useNA = "ifany"))


```


https://oceanhealthindex.org/images/htmls/Supplement.html#62_Biodiversity


## Visualize Species Data

### Flower Plot

```{r}
librarian::shelf(
  dplyr, ggplot2)

# Function to create the flower plot
plot_flower <- function(
    data,
    fld_category,
    fld_height,
    fld_width,
    tooltip_expr = NULL,
    score  = NULL,
    colors = "Set2"){
  
  stopifnot(is.numeric(data |> pull({{ fld_height }})))
  stopifnot(is.numeric(data |> pull({{ fld_width }})))

  if (is.null(score)){
    score <- data |> 
      # ensure both are not just integer (weighted.mean goes to 0)
      mutate(
        "{{fld_height}}" := as.double({{ fld_height }}),
        "{{fld_width}}"  := as.double({{ fld_width  }}) ) |> 
      summarize(
        score = weighted.mean({{ fld_height }}, {{ fld_width }}, na.rm = T)) |> 
      pull(score)
  }

  # Calculate positions
  d <- data |> 
    arrange({{ fld_category }}) |> 
    mutate(across(!where(is.character), as.double)) |> 
    mutate(
      # Calculate angles for plotting
      ymax    = cumsum({{ fld_width }}),
      ymin    = lag(ymax, default=0), # ,  c(0, head(ymax, n=-1)),
      xmax    = {{ fld_height }},
      xmin    = 0)
  
  sym_category <- ensym(fld_category)
  sym_height   <- ensym(fld_height)
  sym_width    <- ensym(fld_width)

  if (!is.null(tooltip_expr)){
    d <- d |> 
      mutate(
        tooltip = glue(tooltip_expr))
  } else {
    d <- d |> 
      mutate(
        tooltip = glue("{!!fld_category}"))
  }
  
  g <- ggplot(d) +
    geom_rect_interactive(aes(
      xmin    = xmin,
      xmax    = xmax,
      ymin    = ymin,
      ymax    = ymax,
      fill    = {{ fld_category }},
      color   = "white",
      data_id = {{ fld_category }},
      tooltip = tooltip),
      color = "white",
      alpha = 0.5) +
    coord_polar(theta = "y") +
    # Create donut hole
    xlim(c(-0.1, max(data |> pull({{ fld_height }})))) +
    # Add center score
    annotate(
      "text", x = -0.1, y = 0, 
      label = round(score, 2), 
      size = 8, 
      fontface = "bold") +
    # Customize appearance
    scale_fill_brewer(
      palette = colors) +
    theme_minimal() +
    # theme_void() +
    theme(
      legend.position = "bottom",
      plot.margin = unit(c(20, 20, 20, 20), "pt"))

  girafe(ggobj = g)
}

g <- d_spp_iucn |> 
  plot_flower(
    taxa,
    iucn_score,
    n_spp,
    tooltip_expr = "{taxa}: {round(iucn_score, 2)} (n_spp: {n_spp})")
g
```

### Species

```{r ply_iucn}
ply_key <- "erCAC-paCEC"

# get species data from db
schema       = "public"
tbl          = "ply_ecoareas"
fld_key      = "ecoarea_key"
tbl_ply_spp  = "ply_species"

d_ply_spp <- tbl(con, "ply_species") |> 
  group_by(ply_key) |> 
  summarize(n = n()) |> 
  collect()
# View(d_ply_spp)

d_spp <- dbGetQuery(con, glue(
  "SELECT * FROM {tbl_ply_spp} 
  WHERE
    ply_tbl = '{schema}.{tbl}' AND 
    ply_fld = '{fld_key}'      AND 
    ply_key = '{ply_key}'")) |> 
  replace_na(list(taxa = "other_taxa")) |> 
  # mutate(
  #   taxa = factor(taxa, levels = sort(names(where_taxa))) |> 
  #     forcats::fct_na_value_to_level("other_taxa")) |> 
  tibble()

tbl(con, tbl_ply_spp) |> 
  group_by(ply_fld) |> 
  summarize(n = n()) |> 
  collect()
#   ply_fld           n
# 1 ecoarea_key   94667
# 2 ecorgn_key    37596

# d_rlcat <- tbl(con, "spp") |> 
#   select(sp_id_gbif, iucnRedListCategory) |> 
#   group_by(iucnRedListCategory) |>
#   summarize(n = n()) |> 
#   arrange(iucnRedListCategory) |> 
#   collect()

d_spp_iucn <- tbl(con, "ply_species") |> 
  rename(sp_key_am = sp_key) |> 
  filter(
    ply_key == !!ply_key) |>   
  replace_na(list(
    taxa = "other_taxa")) |>   
  left_join(
    tbl(con, "spp") |> 
      # filter(!is.na(iucnRedListCategory)) |> 
      select(sp_key_am, sp_id_gbif, iucnRedListCategory) |> 
      mutate(
        iucn_score = case_match(
          iucnRedListCategory,
          # skipped:
          # -  EX : extinct
          # -  NE : not evaluated
          # -  DD : data deficient
          # - <NA>: not available
          # https://oceanhealthindex.org/images/htmls/Supplement.html#62_Biodiversity
          # included:
          #  - CR: Critically Endangered	
          #  - EN: Endangered	
          #  - VU: Vulnerable
          #  - NT: Near Threatened
          #  - LC: Least Concern
          "CR" ~ 1,
          "EN" ~ 0.8,
          "VU" ~ 0.6,
          "NT" ~ 0.4,
          "LC" ~ 0.2)),
    # |> filter(!is.na(iucn_score))
    by = "sp_key_am") |> 
  filter(!is.na(iucn_score)) |> 
  group_by(taxa) |> 
  summarize(
    n_spp      = n(),
    amt        = sum(area_km2 * avg_suit, na.rm=T),
    amt_per_sp = sum(area_km2 * avg_suit, na.rm=T) / n(),
    iucn_score = sum(iucn_score * area_km2 * avg_suit, na.rm=T) / sum(area_km2 * avg_suit, na.rm=T)) |> 
  arrange(taxa) |> 
  collect() # |> 
# View(d_spp_iucn)
# ply_key <- "erCAC-paCEC"
# d_spp_iucn
# # A tibble: 8 × 5
#   taxa            n_spp     amt amt_per_sp iucn_score
#   <chr>         <int64>   <dbl>      <dbl>      <dbl>
# 1 benthos           701  3218.        4.59      0.467
# 2 corals             21   100.        4.78     NA    
# 3 mammals            31  1017.       32.8       0.286
# 4 other_fish        533 12543.       23.5       0.214
# 5 other_inverts     189  1989.       10.5       0.2  
# 6 other_taxa        586  4639.        7.92      0.302
# 7 pelagic_fish       18   280.       15.6       0.246
# 8 turtles             3    69.4      23.1       0.6  
#
# ply_key <- "erCAC"
# d_spp_iucn
# # A tibble: 8 × 5
#   taxa            n_spp    amt amt_per_sp iucn_score
#   <chr>         <int64>  <dbl>      <dbl>      <dbl>
# 1 benthos          1742 21453.       12.3      0.365
# 2 corals             52   776.       14.9      0.24 
# 3 mammals            32  4498.      141.       0.283
# 4 other_fish        763 55395.       72.6      0.211
# 5 other_inverts     269 10515.       39.1      0.205
# 6 other_taxa       1004 25611.       25.5      0.272
# 7 pelagic_fish       23  1306.       56.8      0.238
# 8 turtles             3   299.       99.6      0.6  

d_spp_iucn |> 
  plot_flower(
    fld_category = taxa,
    fld_height   = iucn_score,
    fld_width    = n_spp)

with(
  d_spp_iucn,
  mean(iucn_score))  # 0.3338977
with(
  d_spp_iucn,
  # sum(n_spp * iucn_score) / sum(n_spp)) # 0.285
  # weighted.mean(iucn_score, n_spp, na.rm = T))  # 0 
  weighted.mean(iucn_score, as.double(n_spp), na.rm = T))                    # 0.2828092
weighted.mean(d_spp_iucn$iucn_score, as.double(d_spp_iucn$n_spp), na.rm = T) # 0.2828092

```

- [ply\_boemrgns](https://tile.marinesensitivity.org/public.ply_boemrgns.html#1.94/56.48/-114.43)
- [ply\_ecorgns](https://tile.marinesensitivity.org/public.ply_ecorgns.html#0.94/57.3/0)
- [ply\_planareas](https://tile.marinesensitivity.org/public.ply_planareas.html#0.94/57.3/0)
- [ply\_ecoareas](https://tile.marinesensitivity.org/public.ply_ecoareas.html#0.94/60.9/-93.9)
- [pg\_tileserv: raw.boem\_pc\_blk\_clp](https://tile.marinesensitivity.org/raw.boem_pc_blk_clp.html#4.01/39.93/-123.72)
- [pg\_tileserv: raw.boem\_gom\_blk\_clp](https://tile.marinesensitivity.org/raw.boem_gom_blk_clp.html#5.41/27.082/-89.174)
- [pg\_tileserv: raw.boem\_atl\_blk\_clp](https://tile.marinesensitivity.org/raw.boem_atl_blk_clp.html#3.91/34.97/-73.55)
- [pg\_tileserv: raw.boem\_ak\_blk\_clp](https://tile.marinesensitivity.org/raw.boem_ak_blk_clp.html#0.94/61.3/0)

```{r}



```


$$
amt = n\_cells * avg\_pct * avg\_suit
$$

Amount ($amt$) is the multiplication of the number of cells ($n\_cells$), average percent ($avg\_pct$) of a cell's contents within the selected polygon, and the average Suitability ($avg\_suit$; 0 to 100%) of the species given by AquaMaps.


## Get GBIF occurrences, with iucnRedListCategory

```{r}
librarian::shelf(
  DBI, dplyr, dbplyr, glue, here, 
  # furrr, 
  janitor, purrr, 
  readr, stringr, tictoc, tidyr, rgbif)
source("libs/db.R")

# plan(multicore, workers = availableCores())

if (!"spp" %in% dbListTables(con)){
  # species in ecoareas
  d_spp <- tbl(con, "ply_species") |> 
    filter(ply_tbl == "public.ply_ecoareas") |> 
    # distinct(sp_key, phylum, class, order, family, genus, species) |> 
    mutate(
      am_key   = sp_key,     # AquaMaps key
      rank     = "species",
      sci_name = paste(genus, species)) |> 
    distinct(sci_name, am_key, rank, phylum) |> 
    arrange(sci_name) |>
    collect() |> 
    relocate(sci_name)
  
  # GBIF taxon keys for species
  d_spp_ck <- name_backbone_checklist(d_spp |> select(-am_key))
  # table(d_spp_cklist$confidence)
  # 85    91    95    96    97    98    99   100 
  #  1    10     1    10     8    10    74 10462 
  # sum(is.na(d_spp_cklist$usageKey)) # 0
  
  # add am_key back
  d_spp_ck <- d_spp_ck |> 
    left_join(
      d_spp |> 
        select(am_key, sci_name),
      by = c("verbatim_name" = "sci_name")) |> 
    relocate(am_key)
  
  dbWriteTable(con, Id(schema = "public", table = "spp"), d_spp_ck, append = FALSE, row.names = F)
  
  # comment on table with source (this script) and date created
  dbExecute(
    con,
    sprintf(
    "COMMENT ON TABLE %s IS '%s';", 
    "spp", 
    paste("Created by [workflows: calc\\_ply\\_spp.qmd](https://github.com/MarineSensitivity/workflows/blob/main/calc_ply_spp.qmd)", "Date:", Sys.Date())))
  
  # rename columns in table spp: am_key -> sp_key_am, usageKey -> sp_id_gbif 
  if ("am_key" %in% dbListFields(con, "occ_species"))
    dbExecute(con,"ALTER TABLE spp RENAME COLUMN am_key TO sp_key_am")
  if ("usageKey" %in% dbListFields(con, "occ_species"))
    dbExecute(con,"ALTER TABLE spp RENAME COLUMN \"usageKey\" TO sp_id_gbif")

}

d_spp <- tbl(con, "spp") |> 
  select(am_key, verbatim_name, usageKey) |> 
  collect()

# https://docs.ropensci.org/rgbif/articles/downloading_a_long_species_list.html
# download the data
# SIMPLE_CSV
occ_download(
  pred_in("taxonKey", d_spp$usageKey[1:3]), # important to use pred_in
  pred("hasCoordinate", TRUE),
  pred("hasGeospatialIssue", FALSE),
  format = "SIMPLE_CSV")
```

```
<<gbif download>>
  Your download is being processed by GBIF:
  https://www.gbif.org/occurrence/download/0047937-241126133413365
  Most downloads finish within 15 min.
  Check status with
  occ_download_wait('0047937-241126133413365')
  After it finishes, use
  d <- occ_download_get('0047937-241126133413365') %>%
    occ_download_import()
  to retrieve your download.
Download Info:
  Username: ecoquants
  E-mail: ben@ecoquants.com
  Format: SIMPLE_CSV
  Download key: 0047937-241126133413365
  Created: 2024-12-24T21:28:09.639+00:00
Citation Info:  
  Please always cite the download DOI when using this data.
  https://www.gbif.org/citation-guidelines
  DOI: 10.15468/dl.wan8a3
  Citation:
  GBIF Occurrence Download https://doi.org/10.15468/dl.wan8a3 Accessed from R via rgbif (https://github.com/ropensci/rgbif) on 2024-12-24
```

```{r}
d_occ_csv <- occ_download_get('0047937-241126133413365') %>%
    occ_download_import()

occ_download(
  pred_in("taxonKey", d_spp$usageKey[1:3]), # important to use pred_in
  pred("hasCoordinate", TRUE),
  pred("hasGeospatialIssue", FALSE),
  format = "DWCA")

d_occ_dwca <- occ_download_get('0047938-241126133413365') %>%
  occ_download_import()

setdiff(names(d_occ_csv), names(d_occ_dwca))
# [1] "verbatimScientificNameAuthorship" "publishingOrgKey"     

setdiff(names(d_occ_dwca), names(d_occ_csv))
# [1] "verbatimScientificNameAuthorship" "publishingOrgKey"     

```

```
<<gbif download>>
  Your download is being processed by GBIF:
  https://www.gbif.org/occurrence/download/0047938-241126133413365
  Most downloads finish within 15 min.
  Check status with
  occ_download_wait('0047938-241126133413365')
  After it finishes, use
  d <- occ_download_get('0047938-241126133413365') %>%
    occ_download_import()
  to retrieve your download.
Download Info:
  Username: ecoquants
  E-mail: ben@ecoquants.com
  Format: DWCA
  Download key: 0047938-241126133413365
  Created: 2024-12-24T21:29:23.127+00:00
Citation Info:  
  Please always cite the download DOI when using this data.
  https://www.gbif.org/citation-guidelines
  DOI: 10.15468/dl.f8guzv
  Citation:
  GBIF Occurrence Download https://doi.org/10.15468/dl.f8guzv Accessed from R via rgbif (https://github.com/ropensci/rgbif) on 2024-12-24
```

```{r}
occ_download(
  pred_in("taxonKey", d_spp$usageKey), # important to use pred_in
  pred("hasCoordinate", TRUE),
  pred("hasGeospatialIssue", FALSE),
  format = "DWCA")
```

```
<<gbif download>>
  Your download is being processed by GBIF:
  https://www.gbif.org/occurrence/download/0047939-241126133413365
  Most downloads finish within 15 min.
  Check status with
  occ_download_wait('0047939-241126133413365')
  After it finishes, use
  d <- occ_download_get('0047939-241126133413365') %>%
    occ_download_import()
  to retrieve your download.
Download Info:
  Username: ecoquants
  E-mail: ben@ecoquants.com
  Format: DWCA
  Download key: 0047939-241126133413365
  Created: 2024-12-24T21:33:35.585+00:00
Citation Info:  
  Please always cite the download DOI when using this data.
  https://www.gbif.org/citation-guidelines
  DOI: 10.15468/dl.sspeuj
  Citation:
  GBIF Occurrence Download https://doi.org/10.15468/dl.sspeuj Accessed from R via rgbif (https://github.com/ropensci/rgbif) on 2024-12-24
```

GBIF Occurrence Download https://doi.org/10.15468/dl.sspeuj Accessed from R via rgbif (https://github.com/ropensci/rgbif) on 2024-12-24

```{r}
librarian::shelf(
  dplyr, glue, here, httr2, jsonlite, purrr, readr, rgbif, 
  # ropensci/rredlist, 
  tictoc, tidyr, utils)
source(here("libs/db.R"))

# DEBUG
# options(error=browser) # options(error=NULL)

dir_dl  <- "/share/data/gbifdownload"
dl_key  <- "0047939-241126133413365"
dl_zip  <- glue("{dir_dl}/{dl_key}.zip")
dl_dir  <- glue("{dir_dl}/{dl_key}")
occ_txt <- glue("{dir_dl}/{dl_key}/occurrence.txt")
tbl_spp <- "occ_species"
tbl_occ <- "occs"
# TODO: change on server vs laptop

dir_private <- switch(
  Sys.info()[["sysname"]],
  Darwin = "/Users/bbest/My Drive/private",  # laptop
  Linux  = "/share/private")                 # server
iucn_token_txt <- glue("{dir_private}/iucnredlist.org_api_token_v4.txt")
Sys.setenv(IUCN_REDLIST_KEY = readLines(iucn_token_txt))
# Sys.getenv("IUCN_REDLIST_KEY")

# # red_list_categories ----
# resp <- request("https://api.iucnredlist.org/api/v4/") |>
#   req_headers(Authorization = tkn_v4) |> 
#   req_url_path_append("red_list_categories") |>
#   req_perform()
# 
# d_rlcats <- resp |> 
#   resp_body_json() |>
#   pluck("red_list_categories") |>
#   map_dfr(~ tibble(
#     version     = .x$version, # latest: 3.1
#     code        = .x$code,
#     description = .x$description$en))
# View(d_rlcats)
# 
# # habitats ----
# resp <- request("https://api.iucnredlist.org/api/v4/") |>
#   req_headers(Authorization = tkn_v4) |> 
#   req_url_path_append("habitats") |>
#   req_perform()
# 
# d_rlhabs <- resp |> 
#   resp_body_json() |>
#   pluck("habitats") |>
#   map_dfr(~ tibble(
#     code        = .x$code,
#     description = .x$description$en))
# 
# View(d_rlhabs)
# 
# # habitats. 9 Marine Neritic ----
# resp <- request("https://api.iucnredlist.org/api/v4/") |>
#   req_headers(Authorization = tkn_v4) |> 
#   req_url_path_append("habitats", 9) |>
#   req_url_query(page = 1) |>
#   req_perform()
# 
# d_rlhab9p1 <- resp |> 
#   resp_body_json() |>
#   pluck("assessments") |>
#   map_dfr(~ tibble(
#     code        = .x$code,
#     description = .x$description$en))

if (!file.exists(dl_zip))
  occ_download_get(dl_key, path = dir_dl)
if (!file.exists(dl_dir))
  unzip(dl_zip, exdir = dl_dir)

read_tsv_chunked(
  occ_txt,
  SideEffectChunkCallback$new(
    \(d, pos){
      message(glue("pos: {pos}"))
      
      # glue("{ncol(d)}: {names(d)}") |> paste(collapse = ",\n") |> cat()
      # paste(names(d), collapse = ",\n") |> cat()
      
      # split into columns for taxa vs occurrences
      d_spp <- d |> 
        group_by(
          taxonKey, 
          taxonRank,
          kingdom,
          kingdomKey,
          phylum,
          phylumKey,
          class,
          classKey,
          order,
          orderKey,
          family,
          familyKey,
          genus,
          genusKey,
          subgenus,
          subgenusKey,
          species,
          speciesKey,
          iucnRedListCategory) |> 
        summarize(.groups = "drop")
      
      stopifnot(length(setdiff(unique(d$taxonKey), d_spp$taxonKey)) == 0)
      #stopifnot(sum(duplicated(d_spp$taxonKey)) == 0)
      # TODO: remove duplicate taxonKey
      # TODO: add AquaMaps key sp_key_am (*) vs sp_id_gbif (#) vs sp_key (GBIF:#, AM:*)
      # TODO: rename columns janitor clean style

      if (tbl_spp %in% dbListTables(con)){
        is_tbl_spp_new <- F
        taxonKeys_done <- tbl(con, tbl_spp) |> 
          pull(taxonKey)
        d_spp <- d_spp |> 
          filter(!taxonKey %in% taxonKeys_done)
      } else{
        is_tbl_spp_new <- T
      }
      dbWriteTable(con, tbl_spp, d_spp, append = TRUE, row.names = FALSE)
      
      if (is_tbl_spp_new){
        # TODO: add unique index for taxonKey and convert to long number 
      }
      
      d_occ <- d |> 
        select(
          gbifID, basisOfRecord, 
          taxonKey,
          decimalLatitude, decimalLongitude, coordinateUncertaintyInMeters,
          eventDate, year, month,
          elevation, elevationAccuracy, depth, depthAccuracy,
          datasetKey, lastParsed,
          issue)
      dbWriteTable(con, tbl_occ, d_occ, append = TRUE, row.names = FALSE)
      
    }),
  progress = F)
```

## IUCN RedList, API v4

```{r redlist}

if ("taxonKey" %in% dbListFields(con, "occ_species"))
  dbExecute(
    con,
    "ALTER TABLE occ_species RENAME COLUMN \"taxonKey\" TO sp_id_gbif")

if ("sp_key_gbif" %in% dbListFields(con, "occ_species"))
  dbExecute(
    con,
    "ALTER TABLE occ_species RENAME COLUMN sp_key_gbif TO sp_id_gbif")

if ("sp_key_gbif" %in% dbListFields(con, "spp"))
  dbExecute(
    con,
    "ALTER TABLE spp RENAME COLUMN sp_key_gbif TO sp_id_gbif")

# d_occ_spp <- tbl(con, "spp") |> 
#   select(sp_id_gbif) |> 
#   left_join(
#     tbl(con, "occ_species") |> 
#       distinct(sp_id_gbif, iucnRedListCategory),
#     by = "sp_id_gbif") |> 
#   collect() |> 
#   pull(iucnRedListCategory) |> 
#   table(useNA = "ifany")
# table(d_occ_spp$iucnRedListCategory, useNA = "ifany")
# CR   DD   EN   EX     LC     NE   NT   VU   <NA> 
# 25  114   41    1  1,827  5,157   52   92  3,267
# NE: not evaluated
# <NA>: no occurrences

# add text field iucnRedListCategory to table spp
if (!"iucnRedListCategory" %in% dbListFields(con, "spp"))
  dbExecute(con, "ALTER TABLE spp ADD COLUMN \"iucnRedListCategory\" TEXT")

# update table spp with iucnRedListCategory from table occ_species
dbExecute(
  con,
  "UPDATE spp
    SET \"iucnRedListCategory\" = occ_species.\"iucnRedListCategory\"
    FROM occ_species 
    WHERE occ_species.sp_id_gbif = spp.sp_id_gbif")

# tbl(con, "spp") |> 
#   pull(iucnRedListCategory) |> 
#   table(useNA = "ifany")
# CR   DD   EN   EX   LC   NE   NT   VU <NA> 
# 25  114   41    1 1827 5157   52   92 3267
  
# TODO: fix duplicates
species_xx <- tbl(con, "spp") |> 
  collect() |> 
  filter(duplicated(species)) |> 
  pull(species)
scientificName_xx <- tbl(con, "spp") |> 
  collect() |> 
  filter(duplicated(scientificName)) |> 
  pull(scientificName) # has ({author}, {year})
# length(scientificName_xx)  # 0
canonicalName_xx <- tbl(con, "spp") |> 
  collect() |> 
  filter(duplicated(canonicalName)) |> 
  pull(canonicalName)
# length(canonicalName_xx)  # 0
d_xx <- tbl(con, "spp") |> 
  filter(species %in% species_xx) |> 
  arrange(species) |> 
  collect()
table(d_xx$status)
# ACCEPTED  SYNONYM 
#       89      107
table(d_xx$rank)
# SPECIES 
#     196 


# Dive into duplicate species:
# 1. sp_key_am: SLB-61269; sp_id_gbif: 2261720; 
#   scientificName: Acanella eburnea (Pourtalès, 1868); 
#   status:SYNONYM
#   rank:SPECIES;
#   speciesKey:2261717
#   * https://www.gbif.org/species/2261720
#   
# 2. sp_key_am: SLB-61269; sp_id_gbif: 2261717;           # different
#   scientificName: Acanella arbuscula (Johnson, 1862)   # different 
#   status:ACCEPTED                                      # different
#   rank:SPECIES; speciesKey:2261717                     # same
#   * https://www.gbif.org/species/2261717
# TODO: Check that occurrences of A. eburnea contained in its accepted synonym A. arbuscula?
# TODO: Merge or pick AquaMaps SDM for accepted A. arbuscula over its synonym A. eburnea

(d_species_xxgt2 <- tbl(con, "spp") |> 
    group_by(species) |> 
    summarize(n = n()) |> 
    filter(n > 2))
#   species                    n
#   <chr>                <int64>
# 1 NA                        18
# 2 Lycaea bovallii            3
# 3 Laurencia dendroidea       3
species_xxgt2 <- d_species_xxgt2 |> pull(species)
d_spp_dupesgt2 <- tbl(con, "spp") |> 
  filter(
    is.na(species) |
      species %in% species_xxgt2) |> 
  collect() 
write_csv(d_spp_dupesgt2, "data/spp_duplicatesgt2.csv")
d_spp_dupesgt2 |> 
  select(status,	matchType) |> 
  table()
#           matchType
# status     EXACT HIGHERRANK
#   ACCEPTED     2         16
#   SYNONYM      6          0
d_spp_dupesgt2 |>
  mutate(
    acceptedUsageKey_isna = is.na(acceptedUsageKey)) |> 
  select(acceptedUsageKey_isna,	matchType) |> 
  table()
#                      matchType
# acceptedUsageKey_isna EXACT HIGHERRANK
#                 FALSE     6          0
#                 TRUE      2         16
d_spp_dupesgt2 |>
  mutate(
    acceptedUsageKey_isna = is.na(acceptedUsageKey),
    spidgbif_isusagekey   = sp_id_gbif == acceptedUsageKey) |> 
  select(acceptedUsageKey_isna,	spidgbif_isusagekey) |> 
  table(useNA = "ifany")
#                      spidgbif_isusagekey
# acceptedUsageKey_isna FALSE <NA>
#                 FALSE     6    0
#                 TRUE      0   18

d_spp_dupesgt2_ok <- d_spp_dupesgt2 |> 
  filter(
    status    == "ACCEPTED",
    matchType == "EXACT")
View(d_spp_dupesgt2_ok)


d_spp_rlna <- tbl(con, "spp") |> 
  filter(
    is.na(iucnRedListCategory)) |>  # |
      # iucnRedListCategory %in% c("DD","NE")) |> 
  distinct(sp_id_gbif, species) |>  # TODO: remove/sort duplicates
  arrange(species) |> 
  collect()
sum(duplicated(d_spp_rlna$species))
# nrow(d_spp_rlna) # 8,538 # 3,267

spp <- tbl(con, "spp") |> 
  filter(!is.na(species)) |> 
  distinct(species) |> 
  arrange(species) |> 
  pull(species)

# redo
dbRemoveTable(con, "spp_iucn")
dbRemoveTable(con, "spp_iucn_assessments")
dbRemoveTable(con, "spp_iucn_assessment_details")

for (i in 1:length(spp)){  # i=309
  sp <- spp[i]
  
  message(glue("{format(Sys.time())} {i}/{length(spp)} {sp}"))
  # https://api.iucnredlist.org/api-docs/index.html
  # https://api.iucnredlist.org/api/v4/taxa/scientific_name?genus_name=Ablennes&species_name=hians
  
  req <- request("https://api.iucnredlist.org/api/v4/") |>
    req_headers(Authorization = tkn_v4) |>
    req_url_path_append("taxa/scientific_name") |>
    req_url_query(
      genus_name   = strsplit(sp, " ", fixed = T)[[1]][1],
      species_name = strsplit(sp, " ", fixed = T)[[1]][2]) |> 
    req_error(is_error = \(resp) FALSE)
  resp <- req_perform(req)

  while(resp_status(resp) == 429){
    message("\tretry")
    Sys.sleep(10)
    resp <- req_perform(req)
  }
  if (resp_status(resp) == 404){
    message("\tnot found")
    next
  }
  
  o <- resp |>
    resp_body_json()

  # extract taxonomic info, especially IUCN species identifier sis_id -> sp_id_iucn 
  message("\td_sp")
  d_sp <- o$taxon[
    !names(o$taxon) %in% 
      c("species_taxa", "infrarank_taxa","subpopulation_taxa",
        "ssc_groups", "common_names","synonyms")] |> 
    bind_rows() |> 
    rename(sp_id_iucn = sis_id) |> 
    mutate(
      across(where(is.logical), as.character),
      json = as.character(toJSON(o)))
  # inject into db table
  dbWriteTable(con, "spp_iucn", d_sp, append = T, row.names = F)
  
  # TODO: inject into table spp_iucn
  
  if (length(o$assessments) == 0)
    next
  message("\td_as")
  d_as <- o$assessments %>%
    map_dfr(~{
      # Extract the base level information
      base_info <- list(
        sp_id_iucn                   = .x$sis_taxon_id,
        assessment_id                = .x$assessment_id,
        year_published               = .x$year_published,
        latest                       = .x$latest,
        possibly_extinct             = .x$possibly_extinct,
        possibly_extinct_in_the_wild = .x$possibly_extinct_in_the_wild,
        url                          = .x$url)
      
      # Extract scope information (taking first scope if multiple exist)
      scope_info <- list(
        scope_description = .x$scopes[[1]]$description$en,
        scope_code        = .x$scopes[[1]]$code,
        json              = as.character(toJSON(o)))
      
      # Combine and convert to tibble
      c(base_info, scope_info) %>%
        as_tibble()
    })
  # inject into db table
  dbWriteTable(con, "spp_iucn_assessments", d_as, append = T, row.names = F)
  
  as_id <- d_as |> 
    filter(scope_description == "Global") |> 
    pull(assessment_id)
  if (length(as_id) == 1){
    message("\td_asg")
    # https://api.iucnredlist.org/api/v4/assessment/15603320
    
    req <- request("https://api.iucnredlist.org/api/v4/") |>
      req_headers(Authorization = tkn_v4) |>
      req_url_path_append("assessment",as_id) |> 
      req_error(is_error = \(resp) FALSE)
    resp <- req_perform(req)
    
    while(resp_status(resp) == 429){
      message("\t\tretry")
      Sys.sleep(10)
      resp <- req_perform(req)
    }
    
    o <- resp |>
      resp_body_json()
    
    if ("error" %in% names(o)){
      message("\t\t", o$error)
      next
    }
    
    d_asg <- with(
      o,
      tibble(
        sp_id_iucn             = sis_taxon_id,
        assessment_id          = assessment_id,
        year_published         = year_published,
        red_list_category_code = red_list_category$code,
        population_trend       = population_trend$code,
        assessment_points      = assessment_points,
        assessment_ranges      = assessment_ranges,
        json                   = as.character(toJSON(o)) ))
    
    # inject into db table
    dbWriteTable(con, "spp_iucn_assessment_details", d_asg, append = T, row.names = F)
  }
}
```


```{r redlist ck}
t_spp_iucn <- tbl(con, "spp_iucn") |> 
  collect()
length(spp)       # 10,459
nrow(t_spp_iucn)  #  3,442

stopifnot(nrow(filter(t_spp_iucn, !scientific_name %in% spp)) == 0)

d_spp <- tbl(con, "spp") |> 
  select(sp_key_am, sp_id_gbif, acceptedUsageKey, scientificName, canonicalName, verbatim_name, rank, status, matchType, iucnRedListCategory) |> 
  collect()

stopifnot(sum(duplicated(d_spp$sp_key_am))==0)
table(d_spp$iucnRedListCategory, useNA = "ifany")
# CR   DD   EN   EX   LC   NE   NT   VU <NA> 
# 25  114   41    1 1827 5157   52   92 3267

tbl(con, "spp_iucn") |> 
  collect()

d_spp_iucn <- tbl(con, "spp_iucn") |> 
      select(scientific_name, sp_id_iucn, authority) |> 
      left_join(
        tbl(con, "spp_iucn_assessment_details") |> 
          select(sp_id_iucn, assessment_id, year_published, red_list_category_code),
        by = "sp_id_iucn") |> 
  collect()
table(d_spp_iucn$red_list_category_code, useNA = "ifany")
# CR   DD   EN   LC   NT   VU <NA> 
#  7  135   12 1931   29   21 1307
```


- [rgbif gbif_credentials](https://docs.ropensci.org/rgbif/articles/gbif_credentials.html)\
  `/Users/bbest/My Drive/private/gbif.org_ecoquants.txt`

```{r}
#| eval: false

usethis::edit_r_environ()
```


```{r cleanup, include=FALSE}
# Disconnect from the database
DBI::dbDisconnect(con)
```
